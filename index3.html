<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Box Pyramid Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; } /* Removes default scrollbars */
    </style>
</head>
<body>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- CONFIGURATION ---
    const config = {
        cardWidth: 20,
        cardHeight: 28,
        cardDepth: 2, // Thickness of the 3D Box
        gap: 5,       // Space between cards
        levels: 5     // Height of pyramid
    };

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202025);
    scene.fog = new THREE.Fog(0x202025, 50, 200);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 120);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; // Enable shadows
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(20, 50, 50);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- HELPER: CREATE TEXTURE FROM DATA ---
    // This draws the "HTML-like" content onto a 2D Canvas to use as a skin for the box
    function createCardTexture(name, role, color) {
        const canvas = document.createElement('canvas');
        const width = 512;  // High res for crisp text
        const height = 716; 
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        // 1. Background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);

        // 2. Top Banner / Color splash
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, width, 250);

        // 3. Photo Placeholder (Circle)
        ctx.beginPath();
        ctx.arc(width / 2, 250, 100, 0, Math.PI * 2);
        ctx.fillStyle = '#333';
        ctx.fill();
        ctx.lineWidth = 10;
        ctx.strokeStyle = '#fff';
        ctx.stroke();

        // 4. Text: Name
        ctx.fillStyle = '#333';
        ctx.font = 'bold 60px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(name, width / 2, 450);

        // 5. Text: Role
        ctx.fillStyle = '#777';
        ctx.font = '40px Arial';
        ctx.fillText(role, width / 2, 520);

        // 6. Footer Decoration
        ctx.fillStyle = color;
        ctx.fillRect(40, 600, width - 80, 10);

        return new THREE.CanvasTexture(canvas);
    }

    // --- BUILD PYRAMID ---
    const cardGeometry = new THREE.BoxGeometry(config.cardWidth, config.cardHeight, config.cardDepth);
    const pyramidGroup = new THREE.Group();
    scene.add(pyramidGroup);

    // Material for the SIDES and BACK of the card (Dark Grey Plastic look)
    const sideMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });

    let count = 0;
    const cards = []; // Store references for animation

    for (let row = 0; row < config.levels; row++) {
        const cardsInRow = row + 1;
        
        for (let col = 0; col < cardsInRow; col++) {
            count++;
            
            // Generate a unique texture for this card's FRONT face
            // We use random colors to make them distinct
            const randomColor = `hsl(${Math.random() * 360}, 70%, 50%)`;
            const texture = createCardTexture(`Person ${count}`, "Manager", randomColor);
            
            // Important: Use SRGB encoding for correct colors
            texture.colorSpace = THREE.SRGBColorSpace;

            const frontMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.2 
            });

            // Materials array: [Right, Left, Top, Bottom, Front, Back]
            const materials = [
                sideMaterial, // Right
                sideMaterial, // Left
                sideMaterial, // Top
                sideMaterial, // Bottom
                frontMaterial,// FRONT (Index 4) -> This gets the text/photo
                sideMaterial  // Back
            ];

            const mesh = new THREE.Mesh(cardGeometry, materials);
            
            // Positioning Logic
            const spacingX = config.cardWidth + config.gap;
            const spacingY = config.cardHeight + config.gap;

            const x = (col - (cardsInRow - 1) / 2) * spacingX;
            const y = (config.levels * spacingY) / 2 - (row * spacingY);
            const z = 0;

            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Store original position for hover effects
            mesh.userData = { originalPos: mesh.position.clone() };

            pyramidGroup.add(mesh);
            cards.push(mesh);
        }
    }

    // Center the whole group vertically
    new THREE.Box3().setFromObject(pyramidGroup).getCenter(pyramidGroup.position).multiplyScalar(-1);

    // --- INTERACTION (HOVER EFFECT) ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredCard = null;

    window.addEventListener('mousemove', (event) => {
        // Convert mouse position to -1 to +1 normalized space
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();

        // 1. Raycasting for Hover
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(cards);

        if (intersects.length > 0) {
            // Mouse is over a card
            const object = intersects[0].object;
            if (hoveredCard !== object) {
                // Reset previous
                if (hoveredCard) {
                    hoveredCard.position.lerp(hoveredCard.userData.originalPos, 0.1);
                    hoveredCard.rotation.set(0,0,0);
                }
                hoveredCard = object;
            }

            // Animate Active Card (Pop out + tilt)
            const targetZ = object.userData.originalPos.z + 10;
            object.position.z += (targetZ - object.position.z) * 0.1;
            
            // Subtle tilt towards mouse
            object.rotation.x = -mouse.y * 0.3;
            object.rotation.y = mouse.x * 0.3;

        } else {
            // Mouse is NOT over any card
            if (hoveredCard) {
                // Return to normal
                hoveredCard.position.z += (hoveredCard.userData.originalPos.z - hoveredCard.position.z) * 0.1;
                hoveredCard.rotation.x += (0 - hoveredCard.rotation.x) * 0.1;
                hoveredCard.rotation.y += (0 - hoveredCard.rotation.y) * 0.1;
                
                // Snap to zero if very close
                if(Math.abs(hoveredCard.position.z - hoveredCard.userData.originalPos.z) < 0.01) {
                    hoveredCard.position.copy(hoveredCard.userData.originalPos);
                    hoveredCard.rotation.set(0,0,0);
                    hoveredCard = null;
                }
            }
        }

        controls.update();
        renderer.render(scene, camera);
    }

    animate();

    // --- RESPONSIVE HANDLER ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>